// rta.cpp
// Implements the WCRT analysis for sporadic tasks with jitter by Spuri ("Analysis of deadline scheduled real-time systems", Research report, 1996)

#include "rta.h"
#include "models.h"

// Check necessary conditions for the schedulability of a task set of sporadic tasks with jitter
bool rta::check_necessary_condition(const std::vector<SeqTask> task_set)
{
	double system_utilization = 0.0;
	for (const auto& task : task_set) {
		system_utilization += task.get_utilization();
		if (system_utilization > 1.0) {
			return false;
		}
	}
	return true;
}

static int div_ceil(const int dividend, const int divisor) {
	//double quotient = static_cast<double>(dividend) / static_cast<double>(divisor);
	//return static_cast<int>(std::ceil(quotient));
	return (dividend / divisor) + ((dividend % divisor) != 0);
}

static int div_floor(const int dividend, const int divisor) {
	//double quotient = static_cast<double>(dividend) / static_cast<double>(divisor);
	//return static_cast<int>(std::floor(quotient));
	return (dividend / divisor);
}

// Get workload generated by a task set in an interval of given length
int get_interval_workload(const std::vector<SeqTask> task_set, const int interval_length)
{
	int workload = 0;
	for (const auto& task : task_set) {
		int window_length = interval_length + task.get_jitter();
		if (window_length < interval_length) {
			//std::cout << "get_interval_workload: Busy period length overflow" << std::endl;
			//std::cout << task_set << std::endl;
			return -1;
		}

		int instances = div_ceil(window_length, task.get_period());
		if (workload + (instances * task.get_wcet()) < workload) {
			//std::cout << "get_interval_workload: Busy period length overflow" << std::endl;
			//std::cout << task_set << std::endl;
			return -1;
		}
		workload += instances * task.get_wcet();
	}
	return workload;
}

// Get the maximum possible length of the busy period of a task set
// NOTE: convergence of this algorithm is not guaranteed if the task set does not satisfy the necessary condition for the schedulability
int get_max_busy_period_length(const std::vector<SeqTask> task_set)
{
	int length = 0;
	
	for (const auto& task : task_set) {
		length += task.get_wcet();
	}

	bool update = true;
	while (update) {
		int workload = get_interval_workload(task_set, length);
		if (workload == length) {
			update = false;
		}
		length = workload;

		// check for overflow
		if (workload < 0) {
			//std::cout << "get_max_busy_period_length: Busy period overflow: " << workload << std::endl;
			return -1;
		}
	}

	return length;
}

// Get higher-priority workload for a given task in the task set with respect to a given release offset, interval length, and release time of the first task instance
int get_hp_workload(const std::vector<SeqTask> task_set, const int task_index, const int offset, const int length, const int first_instance)
{
	int jitter = task_set[task_index].get_jitter();
	int wcet = task_set[task_index].get_wcet();
	int period = task_set[task_index].get_period();
	int deadline = task_set[task_index].get_deadline();

	// compute higher-priority workload from instances of the task under analysis
	int delta = 0;
	if (length > first_instance) {
		int released_instances = div_ceil((length - first_instance + jitter), period);
		int deadline_instances = 1 + div_floor((offset + jitter), period);
		delta = std::min(released_instances, deadline_instances) * wcet;
	}

	// compute higher-priority workload from instances of other tasks
	int workload = delta;
	for (auto j = 0; j < task_set.size(); j++) {
		if (j == task_index) {
			continue;
		}

		int jitter_j = task_set[j].get_jitter();
		int wcet_j = task_set[j].get_wcet();
		int period_j = task_set[j].get_period();
		int deadline_j = task_set[j].get_deadline();

		if (deadline_j > (offset + deadline + jitter_j)) {
			continue;
		}

		int released_instances_j = div_ceil((length + jitter_j), period_j);
		int deadline_instances_j = 1 + div_floor((offset + deadline + jitter_j - deadline_j), period_j);
		workload += std::min(released_instances_j, deadline_instances_j) * wcet_j;
	}

	return workload;
}

// Get length of the busy period for a given task in the task set with respect to a given release offset
int get_busy_period_length(const std::vector<SeqTask> task_set, const int task_index, const int offset)
{
	int jitter = task_set[task_index].get_jitter();
	int wcet = task_set[task_index].get_wcet();
	int period = task_set[task_index].get_period();
	int deadline = task_set[task_index].get_deadline();

	// compute the release time of the first instance of the task under analysis
	int floor = div_floor((offset + jitter), period);
	int first_instance = offset + jitter - (floor * period);

	// compute initial value
	int length = 0;
	if (first_instance == 0) {
		length = wcet;
	}
	for (auto j = 0; j < task_set.size(); j++) {
		if (j == task_index) {
			continue;
		}

		int jitter_j = task_set[j].get_jitter();
		int wcet_j = task_set[j].get_wcet();
		int deadline_j = task_set[j].get_deadline();

		if (deadline_j > (offset + deadline + jitter_j)) {
			continue;
		}

		length += wcet_j;
	}

	// compute iteration
	bool update = true;
	while (update) {
		int workload = get_hp_workload(task_set, task_index, offset, length, first_instance);
		if (workload == length) {
			update = false;
		}
		length = workload;
	}

	return length;
}


// Get the WCRT of a task in the task set (inefficient version: evaluates all possible values of the offset variable)
int rta::get_wcrt_inefficient(const std::vector<SeqTask> task_set, const int task_index)
{
	int jitter = task_set[task_index].get_jitter();
	int wcet = task_set[task_index].get_wcet();
	int max_length = get_max_busy_period_length(task_set);

	// report overflow of max length computation
	if (max_length == -1) {
		return -1;
	}

	int offset = -jitter;
	int max_offset = max_length - jitter - wcet;
	int wcrt = 0;
	do {
		int length = get_busy_period_length(task_set, task_index, offset);
		int wcrt_offset = std::max((jitter + wcet), (length - offset));
		//std::cout << "a=" << offset << " r=" << wcrt_offset << std::endl;
		wcrt = std::max(wcrt, wcrt_offset);

		offset++;
	} while (offset < max_offset);

	return wcrt;
}

// Get the WCRT of a task in the task set (efficient version: safely skips redundant values of the offset variable)
int rta::get_wcrt(const std::vector<SeqTask> task_set, const int task_index)
{
	bool return_on_unschedulable = true; // if true, stop the analysis as soon as the current value of the WCRT is above the relative deadline of the task

	int jitter = task_set[task_index].get_jitter();
	int wcet = task_set[task_index].get_wcet();
	int max_length = get_max_busy_period_length(task_set);

	// report overflow of max length computation
	if (max_length == -1) {
		return -1;
	}

	int offset = -jitter;
	int max_offset = max_length - jitter - wcet;
	int wcrt = 0;

	do {
		// evaluate offsets in [-jitter,max_offset)
		// only evaluate offsets for which the first instance of i is in 0
		// and offsets a in A = union_{j=1,...,n, j != i}{a | a = kTj-Jj+Dj-Di, k > 0 in N}
		bool skip = true;

		// compute the release time of the first instance of the task under analysis
		int jitter = task_set[task_index].get_jitter();
		int period = task_set[task_index].get_period();
		int floor = div_floor((offset + jitter), period);
		int first_instance = offset + jitter - (floor * period);
		if (first_instance == 0) {
			skip = false;
		}

		if (skip) {
			for (int j = 0; j < task_set.size(); j++) {
				if (j != task_index) {
					int deadline = task_set[task_index].get_deadline();
					int period_j = task_set[j].get_period();
					int jitter_j = task_set[j].get_jitter();
					int deadline_j = task_set[j].get_deadline();
					int offset_shift = jitter_j - deadline_j + deadline;
					int remainder = (offset_shift + offset) % period_j;
					if (remainder == 0) {
						skip = false;
						break;
					}
				}
			}
		}

		if (skip == false) {
			int length = get_busy_period_length(task_set, task_index, offset);
			int wcrt_offset = std::max((jitter + wcet), (length - offset));
			//std::cout << "a=" << offset << " r=" << wcrt_offset << std::endl;
			wcrt = std::max(wcrt, wcrt_offset);

			if (return_on_unschedulable && (wcrt > task_set[task_index].get_deadline())) {
				return wcrt;
			}
		}

		offset++;

	} while (offset < max_offset);

	return wcrt;
}

// Evaluate the schedulability of the task set using the analysis by Spuri ("Analysis of deadline scheduled real-time systems", Research report, 1996)
bool rta::analyze_task_set(std::vector<SeqTask>& task_set)
{
	bool schedulable = true;
	if (!check_necessary_condition(task_set)) {
		return false;
	}
	
	for (auto i = 0; i < task_set.size(); i++) {
		int wcrt = get_wcrt(task_set, i);

		// manage overflow of busy length calculation
		if (wcrt == -1) {
			schedulable = false;
		}

		task_set[i].set_wcrt_ub(wcrt);
		if (wcrt > task_set[i].get_deadline()) {
			schedulable = false;
		}
	}

	return schedulable;
}

// Runs unit tests for this module
bool rta::test()
{
	std::vector<SeqTask> task_set(3);
	task_set[0] = SeqTask(10, 0, 30, 0, 0);
	task_set[1] = SeqTask(10, 0, 30, 0, 0);
	task_set[2] = SeqTask(20, 0, 30, 0, 0);
	if (check_necessary_condition(task_set)) {
		return false;
	}

	task_set[2] = SeqTask(10, 0, 30, 0, 0);
	if (!check_necessary_condition(task_set)) {
		return false;
	}

	task_set[2] = SeqTask(0, 0, 30, 0, 0);
	if (!check_necessary_condition(task_set)) {
		return false;
	}

	task_set[0] = SeqTask(10, 0, 30, 0, 0);
	task_set[1] = SeqTask(10, 0, 30, 0, 0);
	task_set[2] = SeqTask(0, 0, 30, 0, 0);
	int workload = get_interval_workload(task_set, 0);
	if (workload != 0) {
		return false;
	}
	workload = get_interval_workload(task_set, 10);
	if (workload != 20) {
		return false;
	}
	workload = get_interval_workload(task_set, 30);
	if (workload != 20) {
		return false;
	}
	workload = get_interval_workload(task_set, 50);
	if (workload != 40) {
		return false;
	}

	task_set[0] = SeqTask(1, 0, 3, 0, 0);
	task_set[1] = SeqTask(2, 0, 5, 0, 0);
	task_set[2] = SeqTask(3, 0, 20, 0, 0);
	int length = get_max_busy_period_length(task_set);
	if (length != 14) {
		return false;
	}

	task_set = std::vector<SeqTask>(4);
	task_set[0] = SeqTask(1, 0, 4, 4, 0);
	task_set[1] = SeqTask(2, 0, 6, 9, 0);
	task_set[2] = SeqTask(2, 0, 8, 6, 0);
	task_set[3] = SeqTask(2, 0, 16, 12, 0);
	if (get_hp_workload(task_set, 2, 0, 3, 0) != 3) {
		return false;
	}
	if (get_hp_workload(task_set, 2, 2, 1, 1) != 1) {
		return false;
	}
	if (get_busy_period_length(task_set, 2, 0) != 3) {
		return false;
	}
	if (get_busy_period_length(task_set, 2, 2) != 1) {
		return false;
	}
	if (get_wcrt(task_set, 0) != 2) {
		return false;
	}
	if (get_wcrt(task_set, 1) != 7) {
		return false;
	}
	if (get_wcrt(task_set, 2) != 4) {
		return false;
	}
	if (get_wcrt(task_set, 3) != 10) {
		return false;
	}


	if (get_wcrt(task_set, 0) != get_wcrt_inefficient(task_set, 0)) {
		return false;
	}
	if (get_wcrt(task_set, 1) != get_wcrt_inefficient(task_set, 1)) {
		return false;
	}
	if (get_wcrt(task_set, 2) != get_wcrt_inefficient(task_set, 2)) {
		return false;
	}
	if (get_wcrt(task_set, 3) != get_wcrt_inefficient(task_set, 3)) {
		return false;
	}

	if (!analyze_task_set(task_set)) {
		return false;
	}
	if (task_set[0].get_wcrt_ub() != 2) {
		return false;
	}
	if (task_set[1].get_wcrt_ub() != 7) {
		return false;
	}
	if (task_set[2].get_wcrt_ub() != 4) {
		return false;
	}
	if (task_set[3].get_wcrt_ub() != 10) {
		return false;
	}

	task_set = std::vector<SeqTask>(1);
	task_set[0] = SeqTask(1, 0, 4, 4, 0);
	if (get_wcrt(task_set, 0) != 1) {
		return false;
	}

	task_set = std::vector<SeqTask>(3);
	task_set[0] = SeqTask(1, 1, 4, 4, 0);
	task_set[1] = SeqTask(2, 0, 6, 9, 0);
	task_set[2] = SeqTask(2, 3, 8, 6, 0);
	if (get_max_busy_period_length(task_set) != 11) {
		return false;
	}
	if (get_hp_workload(task_set, 0, -1, 3, 0) != 3) {
		return false;
	}
	if (get_busy_period_length(task_set, 0, -1) != 3) {
		return false;
	}
	if (get_hp_workload(task_set, 0, 0, 3, 1) != 3) {
		return false;
	}
	if (get_busy_period_length(task_set, 0, 0) != 3) {
		return false;
	}

	return true;
}
